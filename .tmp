{
  _readableState: {
    objectMode: false,
    highWaterMark: 16384,
    buffer: {
      head: null,
      tail: null,
      length: 0,
    },
    length: 0,
    pipes: null,
    pipesCount: 0,
    flowing: null,
    ended: true,
    endEmitted: false,
    reading: false,
    sync: true,
    needReadable: false,
    emittedReadable: false,
    readableListening: false,
    resumeScheduled: false,
    emitClose: true,
    autoDestroy: false,
    destroyed: false,
    defaultEncoding: "utf8",
    awaitDrainWriters: null,
    multiAwaitDrain: false,
    readingMore: true,
    decoder: null,
    encoding: null,
  },
  readable: true,
  _events: {
  },
  _eventsCount: 0,
  _maxListeners: undefined,
  socket: {
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: null,
    _readableState: {
      objectMode: false,
      highWaterMark: 16384,
      buffer: {
        head: null,
        tail: null,
        length: 0,
      },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: true,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: "utf8",
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: false,
      decoder: null,
      encoding: null,
    },
    readable: true,
    _events: {
      end: [
        function onReadableStreamEnd() {
          if (!this.allowHalfOpen) {
            this.write = writeAfterFIN;
            if (this.writable)
              this.end();
            else if (!this.writableLength)
              this.destroy();
          } else if (!this.destroyed && !this.writable && !this.writableLength)
            this.destroy();
        },
        function () { [native code] },
      ],
      timeout: function socketOnTimeout() {
        const req = this.parser && this.parser.incoming;
        const reqTimeout = req && !req.complete && req.emit('timeout', this);
        const res = this._httpMessage;
        const resTimeout = res && res.emit('timeout', this);
        const serverTimeout = this.server.emit('timeout', this);
        
        if (!reqTimeout && !resTimeout && !serverTimeout)
          this.destroy();
      },
      data: function () { [native code] },
      error: function socketOnError(e) {
        // Ignore further errors
        this.removeListener('error', socketOnError);
        this.on('error', noop);
        
        if (!this.server.emit('clientError', e, this)) {
          if (this.writable && this.bytesWritten === 0) {
            const response = e.code === 'HPE_HEADER_OVERFLOW' ?
              requestHeaderFieldsTooLargeResponse : badRequestResponse;
            this.write(response);
          }
          this.destroy(e);
        }
      },
      close: [
        function () { [native code] },
        function onServerResponseClose() {
          // EventEmitter.emit makes a copy of the 'close' listeners array before
          // calling the listeners. detachSocket() unregisters onServerResponseClose
          // but if detachSocket() is called, directly or indirectly, by a 'close'
          // listener, onServerResponseClose is still in that copy of the listeners
          // array. That is, in the example below, b still gets called even though
          // it's been removed by a:
          //
          //   var EventEmitter = require('events');
          //   var obj = new EventEmitter();
          //   obj.on('event', a);
          //   obj.on('event', b);
          //   function a() { obj.removeListener('event', b) }
          //   function b() { throw "BAM!" }
          //   obj.emit('event');  // throws
          //
          // Ergo, we need to deal with stale 'close' events and handle the case
          // where the ServerResponse object has already been deconstructed.
          // Fortunately, that requires only a single if check. :-)
          if (this._httpMessage) this._httpMessage.emit('close');
        },
      ],
      drain: function () { [native code] },
      resume: function onSocketResume() {
        // It may seem that the socket is resumed, but this is an enemy's trick to
        // deceive us! `resume` is emitted asynchronously, and may be called from
        // `incoming.readStart()`. Stop the socket again here, just to preserve the
        // state.
        //
        // We don't care about stream semantics for the consumed socket anyway.
        if (this._paused) {
          this.pause();
          return;
        }
        
        if (this._handle && !this._handle.reading) {
          this._handle.reading = true;
          this._handle.readStart();
        }
      },
      pause: function onSocketPause() {
        if (this._handle && this._handle.reading) {
          this._handle.reading = false;
          this._handle.readStop();
        }
      },
    },
    _eventsCount: 8,
    _maxListeners: undefined,
    _writableState: {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: false,
      needDrain: false,
      ending: false,
      ended: false,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: "utf8",
      length: 0,
      writing: false,
      corked: 0,
      sync: true,
      bufferProcessing: false,
      onwrite: function () { [native code] },
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 0,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: {
        next: null,
        entry: null,
        finish: function () { [native code] },
      },
    },
    writable: true,
    allowHalfOpen: true,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: "",
    server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    _server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    timeout: 120000,
    parser: {
      "0": function parserOnHeaders(headers, url) {
        // Once we exceeded headers limit - stop collecting them
        if (this.maxHeaderPairs <= 0 ||
            this._headers.length < this.maxHeaderPairs) {
          this._headers = this._headers.concat(headers);
        }
        this._url += url;
      },
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
        url, statusCode, statusMessage, upgrade,
        shouldKeepAlive) {
        const parser = this;
        const { socket } = parser;
        
        if (headers === undefined) {
        headers = parser._headers;
        parser._headers = [];
        }
        
        if (url === undefined) {
        url = parser._url;
        parser._url = '';
        }
        
        // Parser is also used by http client
        const ParserIncomingMessage = (socket && socket.server &&
        socket.server[kIncomingMessage]) ||
        IncomingMessage;
        
        const incoming = parser.incoming = new ParserIncomingMessage(socket);
        incoming.httpVersionMajor = versionMajor;
        incoming.httpVersionMinor = versionMinor;
        incoming.httpVersion = `${versionMajor}.${versionMinor}`;
        incoming.url = url;
        incoming.upgrade = upgrade;
        
        let n = headers.length;
        
        // If parser.maxHeaderPairs <= 0 assume that there's no limit.
        if (parser.maxHeaderPairs > 0)
        n = MathMin(n, parser.maxHeaderPairs);
        
        incoming._addHeaderLines(headers, n);
        
        if (typeof method === 'number') {
        // server only
        incoming.method = methods[method];
        } else {
        // client only
        incoming.statusCode = statusCode;
        incoming.statusMessage = statusMessage;
        }
        
        return parser.onIncoming(incoming, shouldKeepAlive);
      },
      "2": function parserOnBody(b, start, len) {
        const stream = this.incoming;
        
        // If the stream has already been removed, then drop it.
        if (stream === null)
          return;
        
        // Pretend this was the result of a stream._read call.
        if (len > 0 && !stream._dumped) {
          const slice = b.slice(start, start + len);
          const ret = stream.push(slice);
          if (!ret)
            readStop(this.socket);
        }
      },
      "3": function parserOnMessageComplete() {
        const parser = this;
        const stream = parser.incoming;
        
        if (stream !== null) {
          stream.complete = true;
          // Emit any trailing headers.
          const headers = parser._headers;
          if (headers.length) {
            stream._addHeaderLines(headers, headers.length);
            parser._headers = [];
            parser._url = '';
          }
        
          // For emit end event
          stream.push(null);
        }
        
        // Force to read the next incoming message
        readStart(parser.socket);
      },
      "4": function () { [native code] },
      "5": function () { [native code] },
      _headers: [
      ],
      _url: "",
      socket: [Circular],
      incoming: [Circular],
      outgoing: null,
      maxHeaderPairs: 2000,
      _consumed: true,
      onIncoming: function () { [native code] },
    },
    on: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    addListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    prependListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    _paused: false,
    _httpMessage: {
      _events: {
        finish: function () { [native code] },
      },
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [
      ],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: "",
      finished: false,
      _headerSent: false,
      socket: [Circular],
      connection: [Circular],
      _header: null,
      _keepAliveTimeout: 5000,
      _onPendingData: function () { [native code] },
      _sent100: false,
      _expect_continue: false,
      req: [Circular],
      locals: {
      },
    },
  },
  connection: {
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: null,
    _readableState: {
      objectMode: false,
      highWaterMark: 16384,
      buffer: {
        head: null,
        tail: null,
        length: 0,
      },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: true,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: "utf8",
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: false,
      decoder: null,
      encoding: null,
    },
    readable: true,
    _events: {
      end: [
        function onReadableStreamEnd() {
          if (!this.allowHalfOpen) {
            this.write = writeAfterFIN;
            if (this.writable)
              this.end();
            else if (!this.writableLength)
              this.destroy();
          } else if (!this.destroyed && !this.writable && !this.writableLength)
            this.destroy();
        },
        function () { [native code] },
      ],
      timeout: function socketOnTimeout() {
        const req = this.parser && this.parser.incoming;
        const reqTimeout = req && !req.complete && req.emit('timeout', this);
        const res = this._httpMessage;
        const resTimeout = res && res.emit('timeout', this);
        const serverTimeout = this.server.emit('timeout', this);
        
        if (!reqTimeout && !resTimeout && !serverTimeout)
          this.destroy();
      },
      data: function () { [native code] },
      error: function socketOnError(e) {
        // Ignore further errors
        this.removeListener('error', socketOnError);
        this.on('error', noop);
        
        if (!this.server.emit('clientError', e, this)) {
          if (this.writable && this.bytesWritten === 0) {
            const response = e.code === 'HPE_HEADER_OVERFLOW' ?
              requestHeaderFieldsTooLargeResponse : badRequestResponse;
            this.write(response);
          }
          this.destroy(e);
        }
      },
      close: [
        function () { [native code] },
        function onServerResponseClose() {
          // EventEmitter.emit makes a copy of the 'close' listeners array before
          // calling the listeners. detachSocket() unregisters onServerResponseClose
          // but if detachSocket() is called, directly or indirectly, by a 'close'
          // listener, onServerResponseClose is still in that copy of the listeners
          // array. That is, in the example below, b still gets called even though
          // it's been removed by a:
          //
          //   var EventEmitter = require('events');
          //   var obj = new EventEmitter();
          //   obj.on('event', a);
          //   obj.on('event', b);
          //   function a() { obj.removeListener('event', b) }
          //   function b() { throw "BAM!" }
          //   obj.emit('event');  // throws
          //
          // Ergo, we need to deal with stale 'close' events and handle the case
          // where the ServerResponse object has already been deconstructed.
          // Fortunately, that requires only a single if check. :-)
          if (this._httpMessage) this._httpMessage.emit('close');
        },
      ],
      drain: function () { [native code] },
      resume: function onSocketResume() {
        // It may seem that the socket is resumed, but this is an enemy's trick to
        // deceive us! `resume` is emitted asynchronously, and may be called from
        // `incoming.readStart()`. Stop the socket again here, just to preserve the
        // state.
        //
        // We don't care about stream semantics for the consumed socket anyway.
        if (this._paused) {
          this.pause();
          return;
        }
        
        if (this._handle && !this._handle.reading) {
          this._handle.reading = true;
          this._handle.readStart();
        }
      },
      pause: function onSocketPause() {
        if (this._handle && this._handle.reading) {
          this._handle.reading = false;
          this._handle.readStop();
        }
      },
    },
    _eventsCount: 8,
    _maxListeners: undefined,
    _writableState: {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: false,
      needDrain: false,
      ending: false,
      ended: false,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: "utf8",
      length: 0,
      writing: false,
      corked: 0,
      sync: true,
      bufferProcessing: false,
      onwrite: function () { [native code] },
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 0,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: {
        next: null,
        entry: null,
        finish: function () { [native code] },
      },
    },
    writable: true,
    allowHalfOpen: true,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: "",
    server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    _server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    timeout: 120000,
    parser: {
      "0": function parserOnHeaders(headers, url) {
        // Once we exceeded headers limit - stop collecting them
        if (this.maxHeaderPairs <= 0 ||
            this._headers.length < this.maxHeaderPairs) {
          this._headers = this._headers.concat(headers);
        }
        this._url += url;
      },
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
        url, statusCode, statusMessage, upgrade,
        shouldKeepAlive) {
        const parser = this;
        const { socket } = parser;
        
        if (headers === undefined) {
        headers = parser._headers;
        parser._headers = [];
        }
        
        if (url === undefined) {
        url = parser._url;
        parser._url = '';
        }
        
        // Parser is also used by http client
        const ParserIncomingMessage = (socket && socket.server &&
        socket.server[kIncomingMessage]) ||
        IncomingMessage;
        
        const incoming = parser.incoming = new ParserIncomingMessage(socket);
        incoming.httpVersionMajor = versionMajor;
        incoming.httpVersionMinor = versionMinor;
        incoming.httpVersion = `${versionMajor}.${versionMinor}`;
        incoming.url = url;
        incoming.upgrade = upgrade;
        
        let n = headers.length;
        
        // If parser.maxHeaderPairs <= 0 assume that there's no limit.
        if (parser.maxHeaderPairs > 0)
        n = MathMin(n, parser.maxHeaderPairs);
        
        incoming._addHeaderLines(headers, n);
        
        if (typeof method === 'number') {
        // server only
        incoming.method = methods[method];
        } else {
        // client only
        incoming.statusCode = statusCode;
        incoming.statusMessage = statusMessage;
        }
        
        return parser.onIncoming(incoming, shouldKeepAlive);
      },
      "2": function parserOnBody(b, start, len) {
        const stream = this.incoming;
        
        // If the stream has already been removed, then drop it.
        if (stream === null)
          return;
        
        // Pretend this was the result of a stream._read call.
        if (len > 0 && !stream._dumped) {
          const slice = b.slice(start, start + len);
          const ret = stream.push(slice);
          if (!ret)
            readStop(this.socket);
        }
      },
      "3": function parserOnMessageComplete() {
        const parser = this;
        const stream = parser.incoming;
        
        if (stream !== null) {
          stream.complete = true;
          // Emit any trailing headers.
          const headers = parser._headers;
          if (headers.length) {
            stream._addHeaderLines(headers, headers.length);
            parser._headers = [];
            parser._url = '';
          }
        
          // For emit end event
          stream.push(null);
        }
        
        // Force to read the next incoming message
        readStart(parser.socket);
      },
      "4": function () { [native code] },
      "5": function () { [native code] },
      _headers: [
      ],
      _url: "",
      socket: [Circular],
      incoming: [Circular],
      outgoing: null,
      maxHeaderPairs: 2000,
      _consumed: true,
      onIncoming: function () { [native code] },
    },
    on: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    addListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    prependListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    _paused: false,
    _httpMessage: {
      _events: {
        finish: function () { [native code] },
      },
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [
      ],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: "",
      finished: false,
      _headerSent: false,
      socket: [Circular],
      connection: [Circular],
      _header: null,
      _keepAliveTimeout: 5000,
      _onPendingData: function () { [native code] },
      _sent100: false,
      _expect_continue: false,
      req: [Circular],
      locals: {
      },
    },
  },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: "1.1",
  complete: true,
  headers: {
    host: "localhost:3000",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0",
    accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    dnt: "1",
    connection: "keep-alive",
    "upgrade-insecure-requests": "1",
    "sec-fetch-dest": "document",
    "sec-fetch-mode": "navigate",
    "sec-fetch-site": "none",
    "sec-fetch-user": "?1",
  },
  rawHeaders: [
    "Host",
    "localhost:3000",
    "User-Agent",
    "Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0",
    "Accept",
    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language",
    "en-US,en;q=0.5",
    "Accept-Encoding",
    "gzip, deflate",
    "DNT",
    "1",
    "Connection",
    "keep-alive",
    "Upgrade-Insecure-Requests",
    "1",
    "Sec-Fetch-Dest",
    "document",
    "Sec-Fetch-Mode",
    "navigate",
    "Sec-Fetch-Site",
    "none",
    "Sec-Fetch-User",
    "?1",
  ],
  trailers: {
  },
  rawTrailers: [
  ],
  aborted: false,
  upgrade: false,
  url: "/api/whoami",
  method: "GET",
  statusCode: null,
  statusMessage: null,
  client: {
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: null,
    _readableState: {
      objectMode: false,
      highWaterMark: 16384,
      buffer: {
        head: null,
        tail: null,
        length: 0,
      },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: true,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: "utf8",
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: false,
      decoder: null,
      encoding: null,
    },
    readable: true,
    _events: {
      end: [
        function onReadableStreamEnd() {
          if (!this.allowHalfOpen) {
            this.write = writeAfterFIN;
            if (this.writable)
              this.end();
            else if (!this.writableLength)
              this.destroy();
          } else if (!this.destroyed && !this.writable && !this.writableLength)
            this.destroy();
        },
        function () { [native code] },
      ],
      timeout: function socketOnTimeout() {
        const req = this.parser && this.parser.incoming;
        const reqTimeout = req && !req.complete && req.emit('timeout', this);
        const res = this._httpMessage;
        const resTimeout = res && res.emit('timeout', this);
        const serverTimeout = this.server.emit('timeout', this);
        
        if (!reqTimeout && !resTimeout && !serverTimeout)
          this.destroy();
      },
      data: function () { [native code] },
      error: function socketOnError(e) {
        // Ignore further errors
        this.removeListener('error', socketOnError);
        this.on('error', noop);
        
        if (!this.server.emit('clientError', e, this)) {
          if (this.writable && this.bytesWritten === 0) {
            const response = e.code === 'HPE_HEADER_OVERFLOW' ?
              requestHeaderFieldsTooLargeResponse : badRequestResponse;
            this.write(response);
          }
          this.destroy(e);
        }
      },
      close: [
        function () { [native code] },
        function onServerResponseClose() {
          // EventEmitter.emit makes a copy of the 'close' listeners array before
          // calling the listeners. detachSocket() unregisters onServerResponseClose
          // but if detachSocket() is called, directly or indirectly, by a 'close'
          // listener, onServerResponseClose is still in that copy of the listeners
          // array. That is, in the example below, b still gets called even though
          // it's been removed by a:
          //
          //   var EventEmitter = require('events');
          //   var obj = new EventEmitter();
          //   obj.on('event', a);
          //   obj.on('event', b);
          //   function a() { obj.removeListener('event', b) }
          //   function b() { throw "BAM!" }
          //   obj.emit('event');  // throws
          //
          // Ergo, we need to deal with stale 'close' events and handle the case
          // where the ServerResponse object has already been deconstructed.
          // Fortunately, that requires only a single if check. :-)
          if (this._httpMessage) this._httpMessage.emit('close');
        },
      ],
      drain: function () { [native code] },
      resume: function onSocketResume() {
        // It may seem that the socket is resumed, but this is an enemy's trick to
        // deceive us! `resume` is emitted asynchronously, and may be called from
        // `incoming.readStart()`. Stop the socket again here, just to preserve the
        // state.
        //
        // We don't care about stream semantics for the consumed socket anyway.
        if (this._paused) {
          this.pause();
          return;
        }
        
        if (this._handle && !this._handle.reading) {
          this._handle.reading = true;
          this._handle.readStart();
        }
      },
      pause: function onSocketPause() {
        if (this._handle && this._handle.reading) {
          this._handle.reading = false;
          this._handle.readStop();
        }
      },
    },
    _eventsCount: 8,
    _maxListeners: undefined,
    _writableState: {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: false,
      needDrain: false,
      ending: false,
      ended: false,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: "utf8",
      length: 0,
      writing: false,
      corked: 0,
      sync: true,
      bufferProcessing: false,
      onwrite: function () { [native code] },
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 0,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: {
        next: null,
        entry: null,
        finish: function () { [native code] },
      },
    },
    writable: true,
    allowHalfOpen: true,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: "",
    server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    _server: {
      insecureHTTPParser: undefined,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket
          );
        },
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol];
          
          debug('onconnection');
          
          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }
          
          if (self.maxConnections && self._connections >= self.maxConnections) {
            clientHandle.close();
            return;
          }
          
          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true
          });
          
          self._connections++;
          socket.server = self;
          socket._server = self;
          
          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
        },
      },
      _usingWorkers: false,
      _workers: [
      ],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      httpAllowHalfOpen: false,
      timeout: 120000,
      keepAliveTimeout: 5000,
      maxHeadersCount: null,
      headersTimeout: 60000,
      _connectionKey: "6::::3000",
    },
    timeout: 120000,
    parser: {
      "0": function parserOnHeaders(headers, url) {
        // Once we exceeded headers limit - stop collecting them
        if (this.maxHeaderPairs <= 0 ||
            this._headers.length < this.maxHeaderPairs) {
          this._headers = this._headers.concat(headers);
        }
        this._url += url;
      },
      "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
        url, statusCode, statusMessage, upgrade,
        shouldKeepAlive) {
        const parser = this;
        const { socket } = parser;
        
        if (headers === undefined) {
        headers = parser._headers;
        parser._headers = [];
        }
        
        if (url === undefined) {
        url = parser._url;
        parser._url = '';
        }
        
        // Parser is also used by http client
        const ParserIncomingMessage = (socket && socket.server &&
        socket.server[kIncomingMessage]) ||
        IncomingMessage;
        
        const incoming = parser.incoming = new ParserIncomingMessage(socket);
        incoming.httpVersionMajor = versionMajor;
        incoming.httpVersionMinor = versionMinor;
        incoming.httpVersion = `${versionMajor}.${versionMinor}`;
        incoming.url = url;
        incoming.upgrade = upgrade;
        
        let n = headers.length;
        
        // If parser.maxHeaderPairs <= 0 assume that there's no limit.
        if (parser.maxHeaderPairs > 0)
        n = MathMin(n, parser.maxHeaderPairs);
        
        incoming._addHeaderLines(headers, n);
        
        if (typeof method === 'number') {
        // server only
        incoming.method = methods[method];
        } else {
        // client only
        incoming.statusCode = statusCode;
        incoming.statusMessage = statusMessage;
        }
        
        return parser.onIncoming(incoming, shouldKeepAlive);
      },
      "2": function parserOnBody(b, start, len) {
        const stream = this.incoming;
        
        // If the stream has already been removed, then drop it.
        if (stream === null)
          return;
        
        // Pretend this was the result of a stream._read call.
        if (len > 0 && !stream._dumped) {
          const slice = b.slice(start, start + len);
          const ret = stream.push(slice);
          if (!ret)
            readStop(this.socket);
        }
      },
      "3": function parserOnMessageComplete() {
        const parser = this;
        const stream = parser.incoming;
        
        if (stream !== null) {
          stream.complete = true;
          // Emit any trailing headers.
          const headers = parser._headers;
          if (headers.length) {
            stream._addHeaderLines(headers, headers.length);
            parser._headers = [];
            parser._url = '';
          }
        
          // For emit end event
          stream.push(null);
        }
        
        // Force to read the next incoming message
        readStart(parser.socket);
      },
      "4": function () { [native code] },
      "5": function () { [native code] },
      _headers: [
      ],
      _url: "",
      socket: [Circular],
      incoming: [Circular],
      outgoing: null,
      maxHeaderPairs: 2000,
      _consumed: true,
      onIncoming: function () { [native code] },
    },
    on: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    addListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    prependListener: function socketListenerWrap(ev, fn) {
      const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
      if (!this.parser) {
        this.on = net.Socket.prototype.on;
        this.addListener = net.Socket.prototype.addListener;
        this.prependListener = net.Socket.prototype.prependListener;
        return res;
      }
      
      if (ev === 'data' || ev === 'readable')
        unconsume(this.parser, this);
      
      return res;
    },
    _paused: false,
    _httpMessage: {
      _events: {
        finish: function () { [native code] },
      },
      _eventsCount: 1,
      _maxListeners: undefined,
      outputData: [
      ],
      outputSize: 0,
      writable: true,
      _last: false,
      chunkedEncoding: false,
      shouldKeepAlive: true,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: true,
      sendDate: true,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: null,
      _hasBody: true,
      _trailer: "",
      finished: false,
      _headerSent: false,
      socket: [Circular],
      connection: [Circular],
      _header: null,
      _keepAliveTimeout: 5000,
      _onPendingData: function () { [native code] },
      _sent100: false,
      _expect_continue: false,
      req: [Circular],
      locals: {
      },
    },
  },
  _consuming: false,
  _dumped: false,
  res: {
    _events: {
      finish: function () { [native code] },
    },
    _eventsCount: 1,
    _maxListeners: undefined,
    outputData: [
    ],
    outputSize: 0,
    writable: true,
    _last: false,
    chunkedEncoding: false,
    shouldKeepAlive: true,
    _defaultKeepAlive: true,
    useChunkedEncodingByDefault: true,
    sendDate: true,
    _removedConnection: false,
    _removedContLen: false,
    _removedTE: false,
    _contentLength: null,
    _hasBody: true,
    _trailer: "",
    finished: false,
    _headerSent: false,
    socket: {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: {
        objectMode: false,
        highWaterMark: 16384,
        buffer: {
          head: null,
          tail: null,
          length: 0,
        },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        autoDestroy: false,
        destroyed: false,
        defaultEncoding: "utf8",
        awaitDrainWriters: null,
        multiAwaitDrain: false,
        readingMore: false,
        decoder: null,
        encoding: null,
      },
      readable: true,
      _events: {
        end: [
          function onReadableStreamEnd() {
            if (!this.allowHalfOpen) {
              this.write = writeAfterFIN;
              if (this.writable)
                this.end();
              else if (!this.writableLength)
                this.destroy();
            } else if (!this.destroyed && !this.writable && !this.writableLength)
              this.destroy();
          },
          function () { [native code] },
        ],
        timeout: function socketOnTimeout() {
          const req = this.parser && this.parser.incoming;
          const reqTimeout = req && !req.complete && req.emit('timeout', this);
          const res = this._httpMessage;
          const resTimeout = res && res.emit('timeout', this);
          const serverTimeout = this.server.emit('timeout', this);
          
          if (!reqTimeout && !resTimeout && !serverTimeout)
            this.destroy();
        },
        data: function () { [native code] },
        error: function socketOnError(e) {
          // Ignore further errors
          this.removeListener('error', socketOnError);
          this.on('error', noop);
          
          if (!this.server.emit('clientError', e, this)) {
            if (this.writable && this.bytesWritten === 0) {
              const response = e.code === 'HPE_HEADER_OVERFLOW' ?
                requestHeaderFieldsTooLargeResponse : badRequestResponse;
              this.write(response);
            }
            this.destroy(e);
          }
        },
        close: [
          function () { [native code] },
          function onServerResponseClose() {
            // EventEmitter.emit makes a copy of the 'close' listeners array before
            // calling the listeners. detachSocket() unregisters onServerResponseClose
            // but if detachSocket() is called, directly or indirectly, by a 'close'
            // listener, onServerResponseClose is still in that copy of the listeners
            // array. That is, in the example below, b still gets called even though
            // it's been removed by a:
            //
            //   var EventEmitter = require('events');
            //   var obj = new EventEmitter();
            //   obj.on('event', a);
            //   obj.on('event', b);
            //   function a() { obj.removeListener('event', b) }
            //   function b() { throw "BAM!" }
            //   obj.emit('event');  // throws
            //
            // Ergo, we need to deal with stale 'close' events and handle the case
            // where the ServerResponse object has already been deconstructed.
            // Fortunately, that requires only a single if check. :-)
            if (this._httpMessage) this._httpMessage.emit('close');
          },
        ],
        drain: function () { [native code] },
        resume: function onSocketResume() {
          // It may seem that the socket is resumed, but this is an enemy's trick to
          // deceive us! `resume` is emitted asynchronously, and may be called from
          // `incoming.readStart()`. Stop the socket again here, just to preserve the
          // state.
          //
          // We don't care about stream semantics for the consumed socket anyway.
          if (this._paused) {
            this.pause();
            return;
          }
          
          if (this._handle && !this._handle.reading) {
            this._handle.reading = true;
            this._handle.readStart();
          }
        },
        pause: function onSocketPause() {
          if (this._handle && this._handle.reading) {
            this._handle.reading = false;
            this._handle.readStop();
          }
        },
      },
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: "utf8",
        length: 0,
        writing: false,
        corked: 0,
        sync: true,
        bufferProcessing: false,
        onwrite: function () { [native code] },
        writecb: null,
        writelen: 0,
        afterWriteTickInfo: null,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: {
          next: null,
          entry: null,
          finish: function () { [native code] },
        },
      },
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: "",
      server: {
        insecureHTTPParser: undefined,
        _events: {
          request: function(req, res, next) {
            app.handle(req, res, next);
          },
          connection: function connectionListener(socket) {
            defaultTriggerAsyncIdScope(
              getOrSetAsyncId(socket), connectionListenerInternal, this, socket
            );
          },
        },
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: {
          reading: false,
          onconnection: function onconnection(err, clientHandle) {
            const handle = this;
            const self = handle[owner_symbol];
            
            debug('onconnection');
            
            if (err) {
              self.emit('error', errnoException(err, 'accept'));
              return;
            }
            
            if (self.maxConnections && self._connections >= self.maxConnections) {
              clientHandle.close();
              return;
            }
            
            const socket = new Socket({
              handle: clientHandle,
              allowHalfOpen: self.allowHalfOpen,
              pauseOnCreate: self.pauseOnConnect,
              readable: true,
              writable: true
            });
            
            self._connections++;
            socket.server = self;
            socket._server = self;
            
            DTRACE_NET_SERVER_CONNECTION(socket);
            self.emit('connection', socket);
          },
        },
        _usingWorkers: false,
        _workers: [
        ],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        maxHeadersCount: null,
        headersTimeout: 60000,
        _connectionKey: "6::::3000",
      },
      _server: {
        insecureHTTPParser: undefined,
        _events: {
          request: function(req, res, next) {
            app.handle(req, res, next);
          },
          connection: function connectionListener(socket) {
            defaultTriggerAsyncIdScope(
              getOrSetAsyncId(socket), connectionListenerInternal, this, socket
            );
          },
        },
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: {
          reading: false,
          onconnection: function onconnection(err, clientHandle) {
            const handle = this;
            const self = handle[owner_symbol];
            
            debug('onconnection');
            
            if (err) {
              self.emit('error', errnoException(err, 'accept'));
              return;
            }
            
            if (self.maxConnections && self._connections >= self.maxConnections) {
              clientHandle.close();
              return;
            }
            
            const socket = new Socket({
              handle: clientHandle,
              allowHalfOpen: self.allowHalfOpen,
              pauseOnCreate: self.pauseOnConnect,
              readable: true,
              writable: true
            });
            
            self._connections++;
            socket.server = self;
            socket._server = self;
            
            DTRACE_NET_SERVER_CONNECTION(socket);
            self.emit('connection', socket);
          },
        },
        _usingWorkers: false,
        _workers: [
        ],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        maxHeadersCount: null,
        headersTimeout: 60000,
        _connectionKey: "6::::3000",
      },
      timeout: 120000,
      parser: {
        "0": function parserOnHeaders(headers, url) {
          // Once we exceeded headers limit - stop collecting them
          if (this.maxHeaderPairs <= 0 ||
              this._headers.length < this.maxHeaderPairs) {
            this._headers = this._headers.concat(headers);
          }
          this._url += url;
        },
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
          url, statusCode, statusMessage, upgrade,
          shouldKeepAlive) {
          const parser = this;
          const { socket } = parser;
          
          if (headers === undefined) {
          headers = parser._headers;
          parser._headers = [];
          }
          
          if (url === undefined) {
          url = parser._url;
          parser._url = '';
          }
          
          // Parser is also used by http client
          const ParserIncomingMessage = (socket && socket.server &&
          socket.server[kIncomingMessage]) ||
          IncomingMessage;
          
          const incoming = parser.incoming = new ParserIncomingMessage(socket);
          incoming.httpVersionMajor = versionMajor;
          incoming.httpVersionMinor = versionMinor;
          incoming.httpVersion = `${versionMajor}.${versionMinor}`;
          incoming.url = url;
          incoming.upgrade = upgrade;
          
          let n = headers.length;
          
          // If parser.maxHeaderPairs <= 0 assume that there's no limit.
          if (parser.maxHeaderPairs > 0)
          n = MathMin(n, parser.maxHeaderPairs);
          
          incoming._addHeaderLines(headers, n);
          
          if (typeof method === 'number') {
          // server only
          incoming.method = methods[method];
          } else {
          // client only
          incoming.statusCode = statusCode;
          incoming.statusMessage = statusMessage;
          }
          
          return parser.onIncoming(incoming, shouldKeepAlive);
        },
        "2": function parserOnBody(b, start, len) {
          const stream = this.incoming;
          
          // If the stream has already been removed, then drop it.
          if (stream === null)
            return;
          
          // Pretend this was the result of a stream._read call.
          if (len > 0 && !stream._dumped) {
            const slice = b.slice(start, start + len);
            const ret = stream.push(slice);
            if (!ret)
              readStop(this.socket);
          }
        },
        "3": function parserOnMessageComplete() {
          const parser = this;
          const stream = parser.incoming;
          
          if (stream !== null) {
            stream.complete = true;
            // Emit any trailing headers.
            const headers = parser._headers;
            if (headers.length) {
              stream._addHeaderLines(headers, headers.length);
              parser._headers = [];
              parser._url = '';
            }
          
            // For emit end event
            stream.push(null);
          }
          
          // Force to read the next incoming message
          readStart(parser.socket);
        },
        "4": function () { [native code] },
        "5": function () { [native code] },
        _headers: [
        ],
        _url: "",
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        _consumed: true,
        onIncoming: function () { [native code] },
      },
      on: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      addListener: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      prependListener: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      _paused: false,
      _httpMessage: [Circular],
    },
    connection: {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: {
        objectMode: false,
        highWaterMark: 16384,
        buffer: {
          head: null,
          tail: null,
          length: 0,
        },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        autoDestroy: false,
        destroyed: false,
        defaultEncoding: "utf8",
        awaitDrainWriters: null,
        multiAwaitDrain: false,
        readingMore: false,
        decoder: null,
        encoding: null,
      },
      readable: true,
      _events: {
        end: [
          function onReadableStreamEnd() {
            if (!this.allowHalfOpen) {
              this.write = writeAfterFIN;
              if (this.writable)
                this.end();
              else if (!this.writableLength)
                this.destroy();
            } else if (!this.destroyed && !this.writable && !this.writableLength)
              this.destroy();
          },
          function () { [native code] },
        ],
        timeout: function socketOnTimeout() {
          const req = this.parser && this.parser.incoming;
          const reqTimeout = req && !req.complete && req.emit('timeout', this);
          const res = this._httpMessage;
          const resTimeout = res && res.emit('timeout', this);
          const serverTimeout = this.server.emit('timeout', this);
          
          if (!reqTimeout && !resTimeout && !serverTimeout)
            this.destroy();
        },
        data: function () { [native code] },
        error: function socketOnError(e) {
          // Ignore further errors
          this.removeListener('error', socketOnError);
          this.on('error', noop);
          
          if (!this.server.emit('clientError', e, this)) {
            if (this.writable && this.bytesWritten === 0) {
              const response = e.code === 'HPE_HEADER_OVERFLOW' ?
                requestHeaderFieldsTooLargeResponse : badRequestResponse;
              this.write(response);
            }
            this.destroy(e);
          }
        },
        close: [
          function () { [native code] },
          function onServerResponseClose() {
            // EventEmitter.emit makes a copy of the 'close' listeners array before
            // calling the listeners. detachSocket() unregisters onServerResponseClose
            // but if detachSocket() is called, directly or indirectly, by a 'close'
            // listener, onServerResponseClose is still in that copy of the listeners
            // array. That is, in the example below, b still gets called even though
            // it's been removed by a:
            //
            //   var EventEmitter = require('events');
            //   var obj = new EventEmitter();
            //   obj.on('event', a);
            //   obj.on('event', b);
            //   function a() { obj.removeListener('event', b) }
            //   function b() { throw "BAM!" }
            //   obj.emit('event');  // throws
            //
            // Ergo, we need to deal with stale 'close' events and handle the case
            // where the ServerResponse object has already been deconstructed.
            // Fortunately, that requires only a single if check. :-)
            if (this._httpMessage) this._httpMessage.emit('close');
          },
        ],
        drain: function () { [native code] },
        resume: function onSocketResume() {
          // It may seem that the socket is resumed, but this is an enemy's trick to
          // deceive us! `resume` is emitted asynchronously, and may be called from
          // `incoming.readStart()`. Stop the socket again here, just to preserve the
          // state.
          //
          // We don't care about stream semantics for the consumed socket anyway.
          if (this._paused) {
            this.pause();
            return;
          }
          
          if (this._handle && !this._handle.reading) {
            this._handle.reading = true;
            this._handle.readStart();
          }
        },
        pause: function onSocketPause() {
          if (this._handle && this._handle.reading) {
            this._handle.reading = false;
            this._handle.readStop();
          }
        },
      },
      _eventsCount: 8,
      _maxListeners: undefined,
      _writableState: {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: "utf8",
        length: 0,
        writing: false,
        corked: 0,
        sync: true,
        bufferProcessing: false,
        onwrite: function () { [native code] },
        writecb: null,
        writelen: 0,
        afterWriteTickInfo: null,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: {
          next: null,
          entry: null,
          finish: function () { [native code] },
        },
      },
      writable: true,
      allowHalfOpen: true,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: "",
      server: {
        insecureHTTPParser: undefined,
        _events: {
          request: function(req, res, next) {
            app.handle(req, res, next);
          },
          connection: function connectionListener(socket) {
            defaultTriggerAsyncIdScope(
              getOrSetAsyncId(socket), connectionListenerInternal, this, socket
            );
          },
        },
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: {
          reading: false,
          onconnection: function onconnection(err, clientHandle) {
            const handle = this;
            const self = handle[owner_symbol];
            
            debug('onconnection');
            
            if (err) {
              self.emit('error', errnoException(err, 'accept'));
              return;
            }
            
            if (self.maxConnections && self._connections >= self.maxConnections) {
              clientHandle.close();
              return;
            }
            
            const socket = new Socket({
              handle: clientHandle,
              allowHalfOpen: self.allowHalfOpen,
              pauseOnCreate: self.pauseOnConnect,
              readable: true,
              writable: true
            });
            
            self._connections++;
            socket.server = self;
            socket._server = self;
            
            DTRACE_NET_SERVER_CONNECTION(socket);
            self.emit('connection', socket);
          },
        },
        _usingWorkers: false,
        _workers: [
        ],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        maxHeadersCount: null,
        headersTimeout: 60000,
        _connectionKey: "6::::3000",
      },
      _server: {
        insecureHTTPParser: undefined,
        _events: {
          request: function(req, res, next) {
            app.handle(req, res, next);
          },
          connection: function connectionListener(socket) {
            defaultTriggerAsyncIdScope(
              getOrSetAsyncId(socket), connectionListenerInternal, this, socket
            );
          },
        },
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: {
          reading: false,
          onconnection: function onconnection(err, clientHandle) {
            const handle = this;
            const self = handle[owner_symbol];
            
            debug('onconnection');
            
            if (err) {
              self.emit('error', errnoException(err, 'accept'));
              return;
            }
            
            if (self.maxConnections && self._connections >= self.maxConnections) {
              clientHandle.close();
              return;
            }
            
            const socket = new Socket({
              handle: clientHandle,
              allowHalfOpen: self.allowHalfOpen,
              pauseOnCreate: self.pauseOnConnect,
              readable: true,
              writable: true
            });
            
            self._connections++;
            socket.server = self;
            socket._server = self;
            
            DTRACE_NET_SERVER_CONNECTION(socket);
            self.emit('connection', socket);
          },
        },
        _usingWorkers: false,
        _workers: [
        ],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        maxHeadersCount: null,
        headersTimeout: 60000,
        _connectionKey: "6::::3000",
      },
      timeout: 120000,
      parser: {
        "0": function parserOnHeaders(headers, url) {
          // Once we exceeded headers limit - stop collecting them
          if (this.maxHeaderPairs <= 0 ||
              this._headers.length < this.maxHeaderPairs) {
            this._headers = this._headers.concat(headers);
          }
          this._url += url;
        },
        "1": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
          url, statusCode, statusMessage, upgrade,
          shouldKeepAlive) {
          const parser = this;
          const { socket } = parser;
          
          if (headers === undefined) {
          headers = parser._headers;
          parser._headers = [];
          }
          
          if (url === undefined) {
          url = parser._url;
          parser._url = '';
          }
          
          // Parser is also used by http client
          const ParserIncomingMessage = (socket && socket.server &&
          socket.server[kIncomingMessage]) ||
          IncomingMessage;
          
          const incoming = parser.incoming = new ParserIncomingMessage(socket);
          incoming.httpVersionMajor = versionMajor;
          incoming.httpVersionMinor = versionMinor;
          incoming.httpVersion = `${versionMajor}.${versionMinor}`;
          incoming.url = url;
          incoming.upgrade = upgrade;
          
          let n = headers.length;
          
          // If parser.maxHeaderPairs <= 0 assume that there's no limit.
          if (parser.maxHeaderPairs > 0)
          n = MathMin(n, parser.maxHeaderPairs);
          
          incoming._addHeaderLines(headers, n);
          
          if (typeof method === 'number') {
          // server only
          incoming.method = methods[method];
          } else {
          // client only
          incoming.statusCode = statusCode;
          incoming.statusMessage = statusMessage;
          }
          
          return parser.onIncoming(incoming, shouldKeepAlive);
        },
        "2": function parserOnBody(b, start, len) {
          const stream = this.incoming;
          
          // If the stream has already been removed, then drop it.
          if (stream === null)
            return;
          
          // Pretend this was the result of a stream._read call.
          if (len > 0 && !stream._dumped) {
            const slice = b.slice(start, start + len);
            const ret = stream.push(slice);
            if (!ret)
              readStop(this.socket);
          }
        },
        "3": function parserOnMessageComplete() {
          const parser = this;
          const stream = parser.incoming;
          
          if (stream !== null) {
            stream.complete = true;
            // Emit any trailing headers.
            const headers = parser._headers;
            if (headers.length) {
              stream._addHeaderLines(headers, headers.length);
              parser._headers = [];
              parser._url = '';
            }
          
            // For emit end event
            stream.push(null);
          }
          
          // Force to read the next incoming message
          readStart(parser.socket);
        },
        "4": function () { [native code] },
        "5": function () { [native code] },
        _headers: [
        ],
        _url: "",
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        _consumed: true,
        onIncoming: function () { [native code] },
      },
      on: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      addListener: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      prependListener: function socketListenerWrap(ev, fn) {
        const res = net.Socket.prototype[originalFnName].call(this, ev, fn);
        if (!this.parser) {
          this.on = net.Socket.prototype.on;
          this.addListener = net.Socket.prototype.addListener;
          this.prependListener = net.Socket.prototype.prependListener;
          return res;
        }
        
        if (ev === 'data' || ev === 'readable')
          unconsume(this.parser, this);
        
        return res;
      },
      _paused: false,
      _httpMessage: [Circular],
    },
    _header: null,
    _keepAliveTimeout: 5000,
    _onPendingData: function () { [native code] },
    _sent100: false,
    _expect_continue: false,
    req: [Circular],
    locals: {
    },
  },
  next: function next(err) {
    var layerError = err === 'route'
      ? null
      : err
    
    // remove added slash
    if (slashAdded) {
      req.url = req.url.substr(1)
      slashAdded = false
    }
    
    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl
      req.url = protohost + removed + req.url.substr(protohost.length)
      removed = ''
    }
    
    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }
    
    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError)
      return
    }
    
    // get pathname of request
    var path = getPathname(req)
    
    if (path == null) {
      return done(layerError)
    }
    
    // find next matching layer
    var layer
    var match
    var route
    
    while (match !== true && idx < stack.length) {
      layer = stack[idx++]
      match = matchLayer(layer, path)
      route = layer.route
    
      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match
      }
    
      if (match !== true) {
        continue
      }
    
      if (!route) {
        // process non-route handlers normally
        continue
      }
    
      if (layerError) {
        // routes do not match with a pending error
        match = false
        continue
      }
    
      var method = req.method
      var has_method = route._handles_method(method)
    
      // build up automatic options response
      if (!has_method && method === 'OPTIONS' && methods) {
        methods.push.apply(methods, route._methods())
      }
    
      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false
        continue
      }
    }
    
    // no match
    if (match !== true) {
      return done(layerError)
    }
    
    // store route for dispatch on change
    if (route) {
      req.route = route
    }
    
    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params
    var layerPath = layer.path
    
    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        return next(layerError || err)
      }
    
      if (route) {
        return layer.handle_request(req, res, next)
      }
    
      trim_prefix(layer, layerError, layerPath, path)
    })
  },
  baseUrl: "",
  originalUrl: "/api/whoami",
  _parsedUrl: {
    protocol: null,
    slashes: null,
    auth: null,
    host: null,
    port: null,
    hostname: null,
    hash: null,
    search: null,
    query: null,
    pathname: "/api/whoami",
    path: "/api/whoami",
    href: "/api/whoami",
    _raw: "/api/whoami",
  },
  params: {
  },
  _parsedOriginalUrl: {
    protocol: null,
    slashes: null,
    auth: null,
    host: null,
    port: null,
    hostname: null,
    hash: null,
    search: null,
    query: null,
    pathname: "/api/whoami",
    path: "/api/whoami",
    href: "/api/whoami",
    _raw: "/api/whoami",
  },
  route: {
    path: "/api/whoami",
    stack: [
      {
        handle: (req,res) => {
          res.send(req)
          //res.json({ip:'d', language: 'ds', software:'soft'});
        },
        name: "<anonymous>",
        params: undefined,
        path: undefined,
        keys: [
        ],
        regexp: {
          fast_star: false,
          fast_slash: false,
        },
        method: "get",
      },
    ],
    methods: {
      get: true,
    },
  },
}